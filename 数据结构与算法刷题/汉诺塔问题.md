1. 题目大意
   1. 汉诺塔问题：N个盘子从上到下、从小到大放在A处，另有B、C处可以放盘子，需要用最少步骤将盘子转移到C处  
   2. **每次只能移动 1 个盘子**
   3. **小盘子始终在大盘子上面**
   4. 循环输入盘子数 N（输入0时结束），输出所有的移动步骤( 如"A-->C", "A-->B" )，步骤之间用空格隔开,每输出5个步骤就换行

2. 样例
    * 输入
        ```
      5
      2
      0
      ```
      
    * 输出  
        ```
       A-->C A-->B C-->B A-->C B-->A  
       B-->C A-->C A-->B C-->B C-->A  
       B-->A C-->B A-->C A-->B C-->B  
       A-->C B-->A B-->C A-->C B-->A  
       C-->B C-->A B-->A B-->C A-->C  
       A-->B C-->B A-->C B-->A B-->C  
       A-->C  
       A-->B A-->C B-->C
      ```
       
3. 相关结论  
   1. 对递归的理解
      * 要把 n 个盘子从主轴移到目标轴
        1. 先把最上面( n - 1 )个盘子从主轴移到辅助轴
        2. 再把最后 1 个盘子从主轴移到目标轴
        3. 最后把那( n - 1 )个盘子从辅助轴移到目标轴，放在第 n 个盘子上面
      * 原来就是上面 3 步这么简单，从抽象、整体的思维出发，把这个问题分解成小步骤/更小的问题，转换成编程语言，细节的执行部分交给编译器，只要步骤没错就行
      * 注意终止条件：主轴剩 1 个盘子时直接移到目标轴即可
   2. 移动的最少总步数 = 2^n - 1
      * 设 f(n) = 移动 n 个盘子需要的步数，则 f( n - 1 ) = 移动 n - 1 个盘子需要的步数
      * 移动第 n 个盘子之前需要把( n - 1 )个盘子移到辅助轴上，消耗步数 f( n - 1 )
      * 再把第 n 个盘子从主轴移到目标轴上，消耗 1 步
      * 最后把( n - 1 )个盘子从辅助轴移到目标轴上，消耗步数 f( n - 1 )
      * 于是移动 n 个盘子需要的步数 = f(n) = 2f( n - 1 ) + 1 => 变成高中数列问题
      * An = 2An-1 + 1 <=> An + 1 = 2( An-1 + 1 ) => An + 1 是以 A0 = f(1) = 1 为首项，2 为公比的等差数列
      * f(n) = An = 2^n - 1

4. AI 给的源码( 部分改动 )
``` java
import java.io.*;

public final class Main {
    public static BufferedReader reader = new BufferedReader( new InputStreamReader( System.in ) );
    public static BufferedWriter writer = new BufferedWriter( new OutputStreamWriter( System.out ) );
    public static String space = " ";
    public static int stepCount; // 记录走过的步骤数
    public static int totalSteps; // 记录每次需要的总步数，方便本次循环结束后换行，不影响下一次循环的展示

    public static void main( String[] args ) throws IOException {
        String line;
        while ( ( line = reader.readLine() ) != null ){
            int n = Integer.parseInt( line );
            if ( n == 0 ) break;

            stepCount = 0; // 重置步骤计数
            totalSteps = ( 1 << n ) - 1; // 2^n - 1，左移 n 位 = 乘以 2^n
            moveNPlates( n, 'A', 'B', 'C' ); // 最初起始位置 A, 临时位置 B, 目标位置 C
            writer.flush();
        }
    }

    /**
     * 把 n 个盘子从主轴移到目标轴
     * 
     * @param n 盘子的数量
     * @param from 盘子的起始位置
     * @param temp 临时放盘子的位置
     * @param to 目标位置
     */
    public static void moveNPlates( int n, char from, char temp, char to ){
        if ( n == 1 ){
            // 4. 终止条件：只剩 1 个盘子，直接从它的起始位置移到目标位置
            moveOnePlate( from, to );
        }
        // 1. 先把上面的 n - 1 个盘子从主轴移到辅助轴
        moveNPlates( n - 1, from, to, temp ); // 起始位置 from, 目标位置 temp, 自然把剩下的 to 作为临时位置
        // 2. 再把最下面那个盘子从主轴移到目标轴
        moveOnePlate( from, to );
        // 3. 最后把那 n - 1 个盘子从辅助轴移到目标轴
        moveNPlates( n - 1, temp, from, to ); // 起始位置 temp, 目标位置 to, 自然把剩下的 from 作为临时位置
    }
    
    /**
     * 把 1 个盘子从起始位置移到目标位置
     * 
     * @param from 盘子的起始位置
     * @param to 目标位置
     */
    public static void moveOnePlate( char from, char to ){
        String step = from + "-->" + to + space;
        writer.write( step );
    
        ++stepCount;
        if ( stepCount % 5 == 0 || stepCount = totalSteps ){
            writer.newLine();
        }
    }
}   
```
