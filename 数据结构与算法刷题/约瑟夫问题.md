1. 题目大意  
n个人围成一个圈，分别编号为1、2...n，1号从1开始报数，报到k的人出圈，出圈者的下一号又从1开始报数，直到只剩最后一个人，该人即为胜利者。给出人数n、报数k，求胜利者的编号


2. 最容易想到的模拟...  
遍历数组，指针走了多少次，就是报数多少次，遇到出圈那个人，就踢出去，直到数组只剩1个元素
``` java
public static List< Integer > list = 初始化1~n;
public static void loop( int k ){
    for ( int idx = 0, stepCount = 0; list.size() > 1; 
            idx %= list.size() 
            // 下标对数组长度取余，避免越界（比如下标刚好 = size - 1，然后删除最后一个元素，会出现越界）
        ){
        if ( stepCount == k ){
            list.remove( idx );
            stepCount = 0; // 踢出去后重新计数
            // 后面的人前移，于是不需要移动指针
        } else {
            ++idx;
            ++stepCount;
        }
    }
}
```

3. 用公式计算每次要删除的下标  
在纯模拟的基础上简化了一点...
``` java
int startIdx = 0;
while ( list.size() > 1 ){
    // 被删除的下标 = ( 开始报数的下标 + 报数 - 1 ) % 剩下的人数
    // 从 i 开始, i + k - 1 就是第 k 个人
    endIdx = ( startIdx + k - 1 ) % list.size();
    list.remove( endIdx );
    startIdx = endIdx; // 后面的元素前移，补到 endIdx 的位置
}
```

4. 数学推导  
   1. 给 n 个人编号 0 ~ n-1( 每次出局后重新编号 )
   2. 设 f( n, k ) 为 n 个人，报数为 k 时的胜利者的编号
      * 则 f( n - 1, k ) 表示 n - 1  个人，报数为 k 时的胜利者的编号
      * 要推出通项公式，就是找前后项，即 f( n, k )、f( n - 1, k ) 的关系
   3. 探究 f( n, k )
      * 从 0 开始，第 k 个人的编号 = ( 0 + k - 1 ) % n
      * 设编号 out = ( k - 1 ) % n，于是第1轮 out 出局，又从 out + 1 开始报数
   4. 探究 f( n - 1, k )
      * 此时人数变为 n-1，把原来的编号 out + 1 作为现在的 0，重新编号 0~n-2
      * 现在的 0 → 原来的 out + 1 => 现在的编号 x 对应原来的编号 ( x + out + 1 ) % n
      * 也就是说 1 个人出局后所有编号会按照特定规律变成新的编号
      * 那么再来找 f( n - 1, k )、f( n, k ) 的关系
      * f( n - 1, k ) 是当前编号规则下的胜利者编号，那么就对应了原来的编号 = ( f( n - 1, k ) + out + 1 ) % n
      * 也就是说我们用 f( n- 1, k ) 表示出了原来规则下的胜利者编号
      * 而 f( n, k ) 就是原来的胜利者编号
      * 所以 f( n, k ) = ( f( n - 1, k ) + out + 1 ) % n
   5. 得出结论
      * 数学知识：( a 加减乘以 b ) % p = ( a % p 加减乘以 b % p ) % p
      * **f( n, k )** = ( f( n - 1, k ) + ( k - 1 ) % n + 1 ) % n = ( f( n - 1, k ) + k % n ) % n = **( f( n - 1, k ) + k ) % n**
      * 可以理解为：**同一个人在上一轮的编号 = ( 本轮的编号 + k ) % n**
   6. 最后**记得 + 1**，因为公式的编号从 0 开始，而题目从 1 开始